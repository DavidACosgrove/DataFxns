id: c8cb100d-26b2-362a-f218-19a33091467a
name: Maximum Common Substructre (MCS)
description: Finds one or more MCSs for the structures
category: Chemistry
version: 1.0.0
serviceName: Script
serviceUri: glysade.python
executorId: Glysade.CPythonDataFxn
inputFields:
  - control:
      id: structureColumn
      label: Select structure column
      type: columnselect
      filters:
        - dataType: string
          contentType:
            - chemical/x-mdl-molfile
            - chemical/x-mdl-molfile-v3000
            - chemical/x-smiles
            - chemical/x-daylight-smiles
        - dataType: binary
          contentType:
            - chemical/x-mdl-molfile
            - chemical/x-mdl-molfile-v3000
      validationRules:
        - type: required
          message: Must select column of 2D structures
    request:
      id: structureColumn
      dataType: string
      selectorType: column
  - control:
      id: minMCSMols
      label: Minimum number of molecules for MCS
      type: text
      tooltip: To be reported, an MCS must be in at least this number of molecules
      validationRules:
        - type: numeric
          message: 2
        - type: range
          message: ''
          min: !!int 2
    request:
      id: minMCSMols
      dataType: integer
      data: !!int 2
  - control:
      id: minMCSAtoms
      label: Minimum number of atoms in MCS
      type: text
      tooltip: An MCS will only be reported if it has at least this number of atoms.
      validationRules:
        - type: numeric
          message: ''
        - type: range
          message: ''
          min: !!int 2
    request:
      id: minMCSAtoms
      dataType: integer
      data: !!int 6
  - control:
      id: minMCSBonds
      label: Minimum number of bonds in MCS
      type: text
      tooltip: An MCS will only be reported if it has at least this number of bonds.
      validationRules:
        - type: numeric
          message: ''
        - type: range
          message: ''
          min: !!int 2
    request:
      id: minMCSBonds
      dataType: integer
      data: !!int 6
  - control:
      id: notCompleteRings
      label: MCS can contain partial rings
      type: checkbox
      tooltip: By default, the MCS will contain complete rings, so that, for example, a 5-membered ring won't match part of a 6-membered ring.
    request:
      id: notCompleteRings
      dataType: boolean
      data: !!bool false
  - control:
      id: maxTime
      label: Maximum number of seconds for search
      type: text
      tooltip: If the MCS search exceeds this time, it will return with potentially incomplete results.
      validationRules:
        - type: range
          message: ''
          min: !!int 1
        - type: numeric
          message: ''
    request:
      id: maxTime
      dataType: integer
      data: !!int 300
  - control:
      id: numProcs
      label: Number of parallel processes to use
      type: text
      tooltip: If negative, will use number of CPUs less this number, but at least 1.
      validationRules:
        - type: range
          message: ''
          max: !!int 61
        - type: numeric
          message: ''
    request:
      id: numProcs
      dataType: integer
      data: !!int -1
tags:
  - color: '#50AF28'
    text: chemistry
  - color: '#c6fc00'
    text: calcprop
updateBehavior: automatic
maximumOutputColumns: !!int 2
maximumOutputTables: !!int 1
chemistryFunction: !!bool false
script: |
  import concurrent.futures as cf
  import itertools
  import math
  import os
  from typing import Union
  from rdkit import Chem
  from rdkit.Chem import rdFMCS
  from df.chem_helper import column_to_molecules
  from df.data_transfer import DataFunctionRequest, DataFunctionResponse, DataType, ColumnData, \
      TableData, boolean_input_field, integer_input_field, string_input_field
  from decimal import *
  
  
  def already_have_mcs(mcss: list[dict[str, Union[str, int, Chem.Mol, list[Chem.Mol]]]],
                       new_mcs_dict: dict[str, Union[str, int, Chem.Mol, list[Chem.Mol]]]) -> bool:
      """
      See if we already have the new_mcs_smarts as a substructure.
      Checking the SMARTS strings isn't enough because they aren't
      canonicalised, so check that all the atom lists match.
      Args:
          mcss ([dict, ]):
          new_mcs_dict (dict):
  
      Returns:
          bool
      """
      # print(f'Checking if we have {new_mcs_dict["smartsString"]}'
      #       f' {new_mcs_dict["numMols"]} {new_mcs_dict["numAtoms"]}'
      #       f' {new_mcs_dict["numBonds"]}')
      if new_mcs_dict['smartsString'] in mcss:
          return True
  
      def extract_matches(mcs_dict):
          new_matches = []
          for mol in mcs_dict['mols']:
              matches = mol.GetSubstructMatches(mcs_dict['qmol'])
              match_list = []
              for m in matches:
                  match_list.append(sorted(list(m)))
              match_list.sort()
              new_matches.append(match_list)
          new_matches.sort()
          return new_matches
  
      new_mcs_matches = extract_matches(new_mcs_dict)
      # print(f'new matches : {new_mcs_matches}')
  
      for mcs in mcss:
          # print(f'Against {mcs["smartsString"]}'
          #       f' {mcs["numMols"]} {mcs["numAtoms"]}'
          #       f' {mcs["numBonds"]}')
          if (new_mcs_dict['numAtoms'] == mcs['numAtoms']
                  and new_mcs_dict['numBonds'] == mcs['numBonds']
                  and new_mcs_dict['numMols'] == mcs['numMols']):
              these_matches = extract_matches(mcs)
              if these_matches == new_mcs_matches:
                  # print(f'XXXXXX {mcs["smartsString"]} and {new_mcs_dict["smartsString"]} the same')
                  return True
  
      return False
  
  
  def findSingleMCS(sub_mols: list[Chem.Mol], all_mols: list[Chem.Mol],
                    min_atom_num: int, min_bond_num: int,
                    complete_rings: bool, max_time: int) -> dict[str, Union[str, int, Chem.Mol, list[Chem.Mol]]]:
      """
      Do a single MCS calculation on the given molecules.
      Args:
          sub_mols [Chem.Mol, ]: must be at least 2 molecules in set, obvs.
          all_mols [Chem.Mol, ]: must be at least 2 molecules in set, obvs.
          min_atom_num (int): minimum number of atoms in MCS for it to be
                              returned
          min_bond_num (int): minimum number of bonds in MCS for it to be
                              returned
          complete_rings (bool): if True (default) partial ring matches
                                won't be returned.
          max_time (int): maximum number of seconds to spend on the thing
  
      Returns:
  
      """
      mcs_res = rdFMCS.FindMCS(sub_mols, completeRingsOnly=complete_rings,
                               timeout=max_time)
  
      if (not mcs_res.smartsString
              or mcs_res.numAtoms < min_atom_num
              or mcs_res.numBonds < min_bond_num):
          mcs_dict = {
              'smartsString': '',
              'numAtoms': 0,
              'numBonds': 0,
              'qmol': None,
          }
      else:
          mcs_dict = {
              'smartsString': mcs_res.smartsString,
              'numAtoms': mcs_res.numAtoms,
              'numBonds': mcs_res.numBonds,
              'qmol': Chem.MolFromSmarts(mcs_res.smartsString)
          }
          # find any other molecules with this MCS
          if mcs_dict['qmol'] is not None:
              for mol in all_mols:
                  if mol not in sub_mols and mol.GetSubstructMatch(mcs_dict['qmol']):
                      sub_mols.append(mol)
          mcs_dict['mols'] = sub_mols
          mcs_dict['numMols'] = len(sub_mols)
  
      return mcs_dict
  
  
  def findMCSs(mols: list[Chem.Mol], min_mol_num: int, min_atom_num: int,
               min_bond_num: int, complete_rings: bool = True,
               max_time: int = 600, num_procs: int = -1) -> list[dict[str, Union[str, int, Chem.Mol, list[Chem.Mol]]]]:
      """
  
      Args:
          mols [Chem.Mol, ]: must be at least 2 molecules in set, obvs.
          min_mol_num (int): minimum number of molecules having an MCS for
                           it to be returned.
          min_atom_num (int): minimum number of atoms in MCS for it to be
                              returned
          min_bond_num (int): minimum number of bonds in MCS for it to be
                              returned
          complete_rings (bool): if True (default) partial ring matches
                                won't be returned.
          max_time (int): maximum number of seconds to spend on the
                          thing. Defaults to 600s.
          num_procs (int): number of parallel processes to use.  If -ve,
                           uses os.cpu_count() - num_procs.  Default -1.
                           Obviously final count must be at least 1.
      Returns:
          dict of {str: dict}: dict of dicts with results of different
                               MCSs found.  Inner dict gives details of
                               each MCS and molecules in it.
      """
      mcss = []
      nmols = len(mols)
  
      def stirling_fac(n):
          twopi = Decimal(2 * math.pi)
          e = Decimal(math.e)
          return Decimal.sqrt(twopi * n) * ((n / e) ** n)
  
      nmol_fac = stirling_fac(Decimal(nmols))
      min_mol_num_fac = stirling_fac(Decimal(min_mol_num))
      diff_fac = stirling_fac(Decimal(nmols - min_mol_num))
      approx_ncomb = int(nmol_fac / (min_mol_num_fac * diff_fac))
      print(f'Approximate number of MCS determinations : {approx_ncomb}')
  
      if num_procs < 0:
          num_procs = os.cpu_count() + num_procs
      if num_procs < 1:
          num_procs = 1
  
      with cf.ProcessPoolExecutor(num_procs) as executor:
          futures = []
  
          for comb in itertools.combinations(mols, min_mol_num):
              sub_mols = list(comb)
              fut = executor.submit(findSingleMCS, sub_mols, mols, min_atom_num,
                                    min_bond_num, complete_rings, max_time)
              futures.append(fut)
  
          for fut in cf.as_completed(futures, max_time):
              mcs_dict = fut.result()
              if mcs_dict['smartsString'] and not already_have_mcs(mcss, mcs_dict):
                  mcss.append(mcs_dict)
  
      mcss.sort(key=lambda p: p['numBonds'], reverse=True)
      mcss.sort(key=lambda p: p['numAtoms'], reverse=True)
      mcss.sort(key=lambda p: p['numMols'], reverse=True)
      return mcss
  
  
  def extract_input_values(request: DataFunctionRequest) -> tuple[dict[str, Union[str, int, bool, list[Chem.Mol]]], str]:
    inputs = {}
    column_id = string_input_field(request, 'structureColumn')
    input_column = request.inputColumns[column_id]
    input_column_name = input_column.name
    mols = [m for m in column_to_molecules(input_column) if m is not None]
    inputs['mols'] = mols
    for id in [('minMCSMols', 'min_mol_num'), ('minMCSAtoms', 'min_atom_num'),
               ('minMCSBonds', 'min_bond_num'), ('maxTime', 'max_time'),
               ('numProcs', 'num_procs')]:
        inputs[id[1]] = integer_input_field(request, id[0])
    inputs['complete_rings'] = not boolean_input_field(request, 'notCompleteRings')
    return inputs, input_column_name


  def execute(request: DataFunctionRequest) -> DataFunctionResponse:
      inputs, input_column_name = extract_input_values(request)
      mcss = findMCSs(**inputs)
      smarts = []
      num_mols = []
      for mcs in mcss:
          smarts.append(mcs['smartsString'])
          num_mols.append(mcs['numMols'])
  
      smarts_column = ColumnData(name=f'{input_column_name} MCS SMARTS', dataType=DataType.STRING, values=smarts)
      num_mols_column = ColumnData(name=f'{input_column_name} MCS Mol. Count', dataType=DataType.INTEGER, values=num_mols)
      output_table = TableData(tableName=f'{input_column_name} MCSs', columns=[smarts_column, num_mols_column])
      response = DataFunctionResponse(outputTables=[output_table])
      return response
outputFields:
  - id: table1
    source: table
    type: default
    name: Output MCS table
allowedClients:
  - Analyst
  - WebPlayer
demoUrl:
limitBy: none
