id: b5b991f7-6bfc-d8dd-6281-b6f68917a033
name: PAINS Filters
description: Flags structures if they match a PAINS SMARTS
category: Chemistry
version: 1.0.0
serviceName: Script
serviceUri: glysade.python
executorId: Glysade.CPythonDataFxn
inputFields:
- control:
    id: structureColumn
    label: Select structure column
    type: columnselect
    filters:
    - dataType: string
      contentType:
      - chemical/x-mdl-molfile
      - chemical/x-mdl-molfile-v3000
      - chemical/x-smiles
      - chemical/x-daylight-smiles
    - dataType: binary
      contentType:
      - chemical/x-mdl-molfile
      - chemical/x-mdl-molfile-v3000
    validationRules:
    - type: required
      message: Must select column of 2D structures
  request:
    id: structureColumn
    dataType: string
    selectorType: column
tags:
- color: '#50AF28'
  text: chemistry
- color: '#c6fc00'
  text: calcprop
updateBehavior: automatic
maximumOutputColumns: !!int 1
maximumOutputTables: !!int 0
chemistryFunction: !!bool false
script: |
  from df.chem_helper import column_to_molecules
  from df.data_transfer import DataFunctionRequest, DataFunctionResponse, DataType, ColumnData, \
      string_input_field

  #!/usr/bin/env python
  #
  # file pains.py
  # David Cosgrove
  # CozChemix Limited
  # david@cozchemix.co.uk
  #
  # This script takes a set of molecules and applies SMARTS patterns of
  # the PAINS (Pan-Assay INterference Substructures).  The SMARTS strings
  # are the ones shipped with RDKit in $RDBASE/Data/Pains.
  #
  # This software is provided "as is" and any express or implied
  # warranties including merchantability and fitness for a particular
  # purpose is disclaimed.  In no event shall the authors be liable for
  # any direct, indirect, incidental, special, exemplary, or
  # consequential damages (including, but not limited to, procurement of
  # substitute goods or services; loss of use, data, or profits; or
  # business interruption) however caused and on any theory of liability,
  # whether in contract, strict liability, or tort (including negligence
  # or otherwise) arising in any way out of the use of this software, even
  # if advised of the possibility of such damage.

  import argparse
  import csv
  import os

  from pathlib import Path
  from typing import Union

  from rdkit import Chem


  def parse_args():
      parser = argparse.ArgumentParser(description='Apply PAINS to molecules.')
      parser.add_argument('-I', '--input-file', dest='infile',
                          required=True,
                          help='Name of file containing molecules for'
                              ' analysis.')
      parser.add_argument('-O', '--output-file', dest='outfile',
                          required=True,
                          help='Name of output file.')
      args = parser.parse_args()
      return args


  def create_mol_supplier(infile: str, smiles_header: bool = False) -> Union[Chem.SmilesMolSupplier, Chem.SDMolSupplier, None]:
      """
      Take the input filename and based on extension, return the relevant RDKit
      supplier object.

      Args:
          infile (string):  input molecule file
          smiles_header (bool): whether the SMILES file has a header line.

      Returns:
          RDKit mol supplier
      """

      if infile.endswith('.smi'):
          return Chem.SmilesMolSupplier(infile, titleLine=smiles_header)
      elif infile.endswith('.sdf'):
          return Chem.SDMolSupplier(infile)
      else:
          print(f'ERROR : unknown file type for {infile}.')

      return None


  def build_query_dict(query_defs: dict[str, str]) -> dict[str, Union[Chem.Mol, str]]:
      """
      Makes RDKit query mols for the SMARTS in query_defs
      Args:
          query_defs [dict]:

      Returns:
          dict
      """
      query_dict = {}
      for name, smt in query_defs.items():
          qmol = Chem.MolFromSmarts(smt)
          if not qmol:
              print(f'ERROR : failed to process SMARTS string {smt} with name {name}.')
          else:
              query_dict[name] = {'qmol': qmol, 'SMARTS': smt}

      return query_dict


  def match_queries(mols: list[Chem.Mol], query_dict) -> list[list[str]]:
      """
      Match the queries against the molecules.  Returns list of list of
      strings, 1 entry in outer list for each molecule, giving the
      names of queries that matched.
      Args:
          mols ([Chem.Mol, ]):
          query_dict ({}):

      Returns:
          [[str,], ]
      """
      hits = []
      for i, mol in enumerate(mols):
          mol_hits = []
          for name, query in query_dict.items():
              if mol.HasSubstructMatch(query['qmol']):
                  mol_hits.append(name)
                  # try:
                  #     print(f'{mol.GetProp("_Name")} : {name}')
                  # except KeyError:
                  #     print(f'Molecule number {i} : {name}')
          hits.append(mol_hits)

      return hits


  def run_pains(mols: list[Chem.Mol]) -> list[tuple[bool, str, str]]:
      """
      Run the PAINS filters on each molecule.  Returns a list of tuples.
      Each tuple has a bool for whether it had a PAINS result,
      a string which is the comma-separated list of names of any hits and
      a string which is the dot-separated list of SMARTS patterns of any
      hits.
      Args:
          mols ([Chem.Mol, ]):

      Returns:
          [(bool, str, str), ]
      """
      pains_smarts = read_pains_queries()
      pains_queries = build_query_dict(pains_smarts)
      p_hits = match_queries(mols,pains_queries)
      results = []
      for p_h in p_hits:
          res_str = []
          res_smt = []
          res_bool = False
          if p_h:
              res_str.extend(p_h)
              res_smt.extend([pains_queries[p]["SMARTS"] for p in p_h])
              res_bool = True
          results.append((res_bool, ','.join(res_str), '.'.join(res_smt)))

      return results


  def write_results_to_csv(results: list[tuple[bool, str, str]],
                          mols: list[Chem.Mol], outfile: str) -> None:
      """

      Args:
          results ([[str, ],]):
          mols ([Chem.Mol, ]):
          outfile (str):

      Returns:

      """
      with open(outfile, 'w', newline='') as f:
          csvwriter = csv.writer(f)
          csvwriter.writerow(['Molecule', 'PAINS?', 'PAINS Names', 'PAINS SMARTS'])
          for i, (mol, res) in enumerate(zip(mols, results)):
              try:
                  mol_name = mol.GetProp('_Name')
              except KeyError:
                  mol_name = f'Str_{i}'
              long_res = [mol_name]
              long_res.extend(list(res))
              csvwriter.writerow(long_res)


  def read_pains_queries() -> Union[dict[str, str], None]:
      """
      Read the PAINS SMARTS patterns from
      $RDBASE/Data/Pains/wehi_pains.csv.  Returns None if that file not
      found.
      Returns:
          Dict[str: str]: the SMARTS keyed on name.
      """
      try:
          rdbase = os.environ['RDBASE']
      except KeyError:
          print(f'ERROR : no RDBASE')
          return None

      print(os.environ['RDBASE'])
      pains_defs_file = Path(rdbase) / 'Data' / 'Pains' / 'wehi_pains.csv'
      queries = {}
      try:
          with open(pains_defs_file, 'r', newline='') as f:
              csvreader = csv.reader(f)
              for row in csvreader:
                  smt_name = row[1].replace('<regId=', '').replace('>', '')
                  queries[smt_name] = row[0]

      except IOError:
          print(f'ERROR : no file {pains_defs_file}')
          return None
      return queries


  def main():
      args = parse_args()
      suppl = create_mol_supplier(args.infile)
      mols = []
      for mol in suppl:
          if mol:
              mols.append(mol)
      print(f'number of mols : {len(mols)}')
      results = run_pains(mols)
      for mol, res in zip(mols, results):
          if res[0]:
              print(f'{mol.GetProp("_Name")} : {res}')
      write_results_to_csv(results, mols, args.outfile)


  if __name__ == '__main__':
      main()

  def execute(request: DataFunctionRequest) -> DataFunctionResponse:
      column_id = string_input_field(request, 'structureColumn')
      input_column = request.inputColumns[column_id]
      mols = column_to_molecules(input_column)
      pains = run_pains(mols)
      pains_cols = [p[0] for p in pains]
      pains_column = ColumnData(name=f'{input_column.name} PAINS?', dataType=DataType.BOOLEAN, values=pains_cols)
      pains_strs = [p[1] for p in pains]
      pains_strs_column = ColumnData(name=f'{input_column.name} PAINS NAMES', dataType=DataType.STRING, values=pains_strs)
      pains_smarts = [p[2] for p in pains]
      pains_smarts_column = ColumnData(name=f'{input_column.name} PAINS SMARTS', dataType=DataType.STRING, values=pains_smarts)
      response = DataFunctionResponse(outputColumns=[pains_column, pains_strs_column, pains_smarts_column])
      return response
outputFields:
- id: structureColumn
  source: inputField
  type: default
  name: Structure column
- id: column1
  source: column
  type: filter
  name: Output exact mass column
allowedClients:
- Analyst
- WebPlayer
demoUrl: 
limitBy: none
