id: b5b991f7-6bfc-d8dd-6281-b6f68917a033
name: PAINS Filters
description: Flags structures if they match a PAINS SMARTS
category: Chemistry
version: 1.0.0
serviceName: Script
serviceUri: glysade.python
executorId: Glysade.CPythonDataFxn
inputFields:
- control:
    id: structureColumn
    label: Select structure column
    type: columnselect
    filters:
    - dataType: string
      contentType:
      - chemical/x-mdl-molfile
      - chemical/x-mdl-molfile-v3000
      - chemical/x-smiles
      - chemical/x-daylight-smiles
    - dataType: binary
      contentType:
      - chemical/x-mdl-molfile
      - chemical/x-mdl-molfile-v3000
    validationRules:
    - type: required
      message: Must select column of 2D structures
  request:
    id: structureColumn
    dataType: string
    selectorType: column
tags:
- color: '#50AF28'
  text: chemistry
- color: '#c6fc00'
  text: calcprop
updateBehavior: automatic
maximumOutputColumns: !!int 3
maximumOutputTables: !!int 0
chemistryFunction: !!bool false
script: |
  import csv
  import os
  
  from pathlib import Path
  from typing import Union
  
  from rdkit import Chem
  from df.chem_helper import column_to_molecules
  from df.data_transfer import DataFunctionRequest, DataFunctionResponse, DataType, ColumnData, \
      string_input_field

  def build_query_dict(query_defs: dict[str, str]) -> dict[str, Union[Chem.Mol, str]]:
      """
      Makes RDKit query mols for the SMARTS in query_defs
      Args:
          query_defs [dict]:
  
      Returns:
          dict
      """
      query_dict = {}
      for name, smt in query_defs.items():
          qmol = Chem.MolFromSmarts(smt)
          if not qmol:
              print(f'ERROR : failed to process SMARTS string {smt} with name {name}.')
          else:
              query_dict[name] = {'qmol': qmol, 'SMARTS': smt}
  
      return query_dict
  
  
  def match_queries(mols: list[Chem.Mol], query_dict) -> list[list[str]]:
      """
      Match the queries against the molecules.  Returns list of list of
      strings, 1 entry in outer list for each molecule, giving the
      names of queries that matched.
      Args:
          mols ([Chem.Mol, ]):
          query_dict ({}):
  
      Returns:
          [[str,], ]
      """
      hits = []
      for i, mol in enumerate(mols):
          mol_hits = []
          if mol is not None and mol:
              for name, query in query_dict.items():
                  if mol.HasSubstructMatch(query['qmol']):
                      mol_hits.append(name)
                      # try:
                      #     print(f'{mol.GetProp("_Name")} : {name}')
                      # except KeyError:
                      #     print(f'Molecule number {i} : {name}')
          hits.append(mol_hits)
  
      return hits
  
  
  def run_pains(mols: list[Chem.Mol]) -> list[tuple[bool, str, str]]:
      """
      Run the PAINS filters on each molecule.  Returns a list of tuples.
      Each tuple has a bool for whether it had a PAINS result,
      a string which is the comma-separated list of names of any hits and
      a string which is the dot-separated list of SMARTS patterns of any
      hits.
      Args:
          mols ([Chem.Mol, ]):
  
      Returns:
          [(bool, str, str), ]
      """
      pains_smarts = read_pains_queries()
      pains_queries = build_query_dict(pains_smarts)
      p_hits = match_queries(mols,pains_queries)
      results = []
      for p_h in p_hits:
          res_str = []
          res_smt = []
          res_bool = False
          if p_h:
              res_str.extend(p_h)
              res_smt.extend([pains_queries[p]["SMARTS"] for p in p_h])
              res_bool = True
          results.append((res_bool, ','.join(res_str), '.'.join(res_smt)))
  
      return results
  
  
  def read_pains_queries() -> Union[dict[str, str], None]:
      """
      Read the PAINS SMARTS patterns from
      $RDBASE/Data/Pains/wehi_pains.csv.  Returns None if that file not
      found.
      Returns:
          Dict[str: str]: the SMARTS keyed on name.
      """
      try:
          rdbase = os.environ['RDBASE']
      except KeyError:
          print(f'ERROR : no RDBASE')
          return None
  
      print(os.environ['RDBASE'])
      pains_defs_file = Path(rdbase) / 'Data' / 'Pains' / 'wehi_pains.csv'
      queries = {}
      try:
          with open(pains_defs_file, 'r', newline='') as f:
              csvreader = csv.reader(f)
              for row in csvreader:
                  smt_name = row[1].replace('<regId=', '').replace('>', '')
                  queries[smt_name] = row[0]
  
      except IOError:
          print(f'ERROR : no file {pains_defs_file}')
          return None
      return queries
  
  
  def execute(request: DataFunctionRequest) -> DataFunctionResponse:
      column_id = string_input_field(request, 'structureColumn')
      input_column = request.inputColumns[column_id]
      mols = column_to_molecules(input_column)
      pains = run_pains(mols)
      pains_cols = [p[0] for p in pains]
      pains_column = ColumnData(name=f'{input_column.name} PAINS?', dataType=DataType.BOOLEAN, values=pains_cols)
      pains_strs = [p[1] for p in pains]
      pains_strs_column = ColumnData(name=f'{input_column.name} PAINS NAMES', dataType=DataType.STRING, values=pains_strs)
      pains_smarts = [p[2] for p in pains]
      pains_smarts_column = ColumnData(name=f'{input_column.name} PAINS SMARTS', dataType=DataType.STRING, values=pains_smarts)
      response = DataFunctionResponse(outputColumns=[pains_column, pains_strs_column, pains_smarts_column])
      return response
outputFields:
- id: structureColumn
  source: inputField
  type: default
  name: Structure column
- id: column1
  source: column
  type: filter
- id: column2
  source: column
  type: default
- id: column3
  source: column
  type: molecule
allowedClients:
- Analyst
- WebPlayer
demoUrl: 
limitBy: none
